<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"/>
<title>Spartacus RR • Self-Check & Auto-Fix</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin>
<style>
  *{box-sizing:border-box}
  html,body,#map{height:100%;margin:0}
  #map{background:#eef2f7;}
  /* Status-Bar */
  #status{
    position:fixed; z-index:6000; top:0; left:0; right:0;
    display:flex; gap:10px; align-items:center; padding:8px 12px;
    font:14px system-ui,-apple-system,Segoe UI,Roboto; color:#111; background:#fff; border-bottom:1px solid #e9e9e9;
  }
  .pill{display:flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; font-size:12px; border:1px solid #ddd; background:#fafafa}
  .ok{background:#e8f7ee;border-color:#bfe6cd}
  .warn{background:#fff7e6;border-color:#ffe0a6}
  .err{background:#ffecec;border-color:#ffb6b6}
  .dot{width:8px; height:8px; border-radius:50%}
  .ok .dot{background:#16a34a} .warn .dot{background:#d97706} .err .dot{background:#dc2626}
  .sp{flex:1}
  .btn{border:1px solid #dcdcdc; background:#fff; border-radius:8px; padding:6px 10px; cursor:pointer}
  /* Drawer */
  #drawer{
    position:fixed; z-index:5000; top:56px; right:12px; width:min(420px,94vw); max-height:72vh; overflow:auto;
    background:#fff; border:1px solid #e5e5e5; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.18);
    transform:translateX(110%); transition:transform .22s ease-out; padding:12px;
    font:14px system-ui,-apple-system,Segoe UI,Roboto;
  }
  #drawer.open{ transform:none; }
  .row{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .kb{ min-width:32px; height:28px; border:1px solid #ddd; border-radius:6px; background:#fafafa; cursor:pointer }
  label{font-size:12px}
  .hint{font-size:12px; opacity:.7}
  input[type="date"]{padding:4px 6px; border:1px solid #ddd; border-radius:6px; font:14px system-ui}
  input[type="range"], select{width:180px}
  .progress{height:6px; background:#eee; border-radius:999px; overflow:hidden; width:100%}
  .bar{height:100%; width:0%; background:#4f46e5; transition:width .15s}
  /* Legend */
  .leaflet-control.legend { background:#fff; padding:8px; border-radius:10px; border:1px solid #e5e5e5; box-shadow:0 2px 8px rgba(0,0,0,.12); font:14px system-ui; }
  #legendCanvas{ display:block; width:240px; height:12px; image-rendering:pixelated; }
  .legend-row{ display:flex; justify-content:space-between; margin-top:4px; font-size:12px; }
  /* Map overlay img */
  .leaflet-overlay-pane img.leaflet-image-layer{
    image-rendering:pixelated; background:transparent !important; mix-blend-mode:normal !important; filter:none !important;
  }
  /* Gear */
  .gear-btn{
    position:fixed; z-index:5000; top:60px; right:12px;
    background:#fff; border:1px solid #e5e5e5; border-radius:10px; width:42px; height:42px;
    display:grid; place-items:center; font-size:18px; box-shadow:0 2px 8px rgba(0,0,0,.12);
  }
</style>
</head>
<body>
  <!-- Statusleiste -->
  <div id="status">
    <div id="st-init"  class="pill warn"><span class="dot"></span>Init</div>
    <div id="st-bbox"  class="pill warn"><span class="dot"></span>BBOX</div>
    <div id="st-dates" class="pill warn"><span class="dot"></span>Datum</div>
    <div id="st-fetch" class="pill warn"><span class="dot"></span>Fetch</div>
    <div id="st-draw"  class="pill warn"><span class="dot"></span>Render</div>
    <div class="sp"></div>
    <button id="rerun" class="btn">↺ Neu versuchen</button>
    <button id="openDrawer" class="btn">⚙️</button>
  </div>

  <div id="map"></div>

  <!-- Drawer -->
  <div id="drawer" aria-hidden="true">
    <div class="row" style="justify-content:space-between; width:100%">
      <div>
        <div><strong>RR 14-Tage (SPARTACUS v2) — Auto-Fix</strong></div>
        <div class="hint">Startet automatisch • zeigt Status oben</div>
      </div>
      <button class="kb" id="renderBtn">Laden &amp; Rendern</button>
    </div>

    <div class="row">
      <label>Bundesland:&nbsp;
        <select id="preset">
          <option value="noe">Niederösterreich</option>
          <option value="stmk">Steiermark</option>
        </select>
      </label>
      <button class="kb" id="applyPreset">Übernehmen</button>
      <button class="kb" id="dbgPattern" title="Schachbrett">Debug: Testbild</button>
      <button class="kb" id="dbgCells" title="Zellen bunt">Debug: Zellen</button>
    </div>

    <div class="row">
      <label>Von: <input type="date" id="start"></label>
      <label>Bis: <input type="date" id="end"></label>
    </div>

    <div class="row">
      <label>BBOX&nbsp;<span class="hint">(s,w,n,e)</span>:</label>
      <input id="bbox" style="flex:1;min-width:200px;padding:6px;border:1px solid #ddd;border-radius:6px"
             value="47.419564822,14.450844322,49.024548178,17.075640678">
    </div>

    <div class="row" style="width:100%">
      <div class="progress" style="flex:1"><div class="bar" id="bar"></div></div>
      <div style="min-width:52px;text-align:right"><code id="pct">0%</code></div>
    </div>

    <div class="row">
      <label>Overlay&nbsp;<input type="range" id="opacity" min="30" max="100" value="90">
        <span id="ovv">90%</span></label>
      <button class="kb" id="dlPng">PNG</button>
      <button class="kb" id="resetTuning">Justage reset</button>
    </div>

    <div style="margin:6px 0;border-top:1px solid #eee"></div>
    <div class="row"><strong>Kachelgröße (px)</strong> <span class="hint">(wirkt live)</span></div>
    <div class="row">
      <label>X: <input type="range" id="tileX" min="200" max="600" step="5" value="200"> <span id="tileXVal">200%</span></label>
      <code id="tileXpx">– px</code>
    </div>
    <div class="row">
      <label>Y: <input type="range" id="tileY" min="200" max="600" step="5" value="200"> <span id="tileYVal">200%</span></label>
      <code id="tileYpx">– px</code>
    </div>

    <div style="margin:6px 0;border-top:1px solid #eee"></div>
    <div class="row">
      <label>Palette:&nbsp;
        <select id="palette">
          <option value="spectral">Spectral</option>
          <option value="rainbow">Rainbow</option>
          <option value="viridis">Viridis</option>
        </select>
      </label>
    </div>
  </div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>
<script>
/*** ========= Mini-Framework: Status, Auto-Fix, nie „leer“ ========= ***/
const API = 'https://dataset.api.hub.geosphere.at/v1/grid/historical/spartacus-v2-1d-1km';
const PARAM = 'RR';
const SPARTACUS_BOUNDS = Object.freeze({ south:46.16133, west:9.393909, north:49.17754, east:17.38218 });
const CANVAS_W = 1400;

const statusEls = {
  init:  document.getElementById('st-init'),
  bbox:  document.getElementById('st-bbox'),
  dates: document.getElementById('st-dates'),
  fetch: document.getElementById('st-fetch'),
  draw:  document.getElementById('st-draw')
};
function mark(el, cls, txt){ el.classList.remove('ok','warn','err'); el.classList.add(cls); if(txt) el.lastChild.nodeValue = txt; }
function ok(k,t){ mark(statusEls[k],'ok',  t||statusEls[k].textContent); }
function warn(k,t){ mark(statusEls[k],'warn',t||statusEls[k].textContent); }
function err(k,t){ mark(statusEls[k],'err', t||statusEls[k].textContent); }

const bar=document.getElementById('bar'), pct=document.getElementById('pct');
function progress(frac){ const p=Math.max(0,Math.min(1,frac||0)); bar.style.width=(Math.round(p*100))+'%'; pct.textContent=(Math.round(p*100))+'%'; }

function clamp(v,min,max){ return Math.min(max, Math.max(min, v)); }
function clampBBox([s,w,n,e]){
  s=clamp(s,SPARTACUS_BOUNDS.south,SPARTACUS_BOUNDS.north);
  n=clamp(n,SPARTACUS_BOUNDS.south,SPARTACUS_BOUNDS.north);
  w=clamp(w,SPARTACUS_BOUNDS.west, SPARTACUS_BOUNDS.east);
  e=clamp(e,SPARTACUS_BOUNDS.west, SPARTACUS_BOUNDS.east);
  const eps=1e-6; if(n<=s) n=Math.min(SPARTACUS_BOUNDS.north, s+eps); if(e<=w) e=Math.min(SPARTACUS_BOUNDS.east, w+eps);
  return [s,w,n,e];
}
function yesterday(){ const t=new Date(); t.setDate(t.getDate()-1); return t.toISOString().slice(0,10); }
function start14(){ const e=new Date(); e.setDate(e.getDate()-1); const s=new Date(e); s.setDate(s.getDate()-13); return s.toISOString().slice(0,10); }

/* Map */
const map = L.map('map',{zoomControl:false}).setView([47.6,14.3],7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap'}).addTo(map);
const overlayOptions={opacity:0.9,interactive:false};
let overlay=null, baseBounds=null, baseBoundsObj=null, lastCells=null, lastCanvas=null, lastStepPx=null;

/* UI basic */
const drawer=document.getElementById('drawer'), openDrawer=document.getElementById('openDrawer');
openDrawer.addEventListener('click', ()=> drawer.classList.toggle('open'));
document.getElementById('rerun').addEventListener('click', ()=> autoRun(true));
document.getElementById('renderBtn').addEventListener('click', ()=> autoRun(true));

/* Presets */
const PRESETS = {
  noe:[47.419564822,14.450844322,49.024548178,17.075640678],
  stmk:[46.35,13.55,47.75,16.51]
};
const presetSel=document.getElementById('preset');
document.getElementById('applyPreset').addEventListener('click', ()=>{
  const bb=PRESETS[presetSel.value]||PRESETS.noe;
  document.getElementById('bbox').value=bb.join(',');
  autoRun(true);
});

/* Dates */
const startEl=document.getElementById('start'), endEl=document.getElementById('end');
(function(){ startEl.value=start14(); endEl.value=yesterday(); })();

/* Palette */
const paletteSel=document.getElementById('palette'); let currentPalette=localStorage.getItem('ovPalette')||'spectral'; paletteSel.value=currentPalette;
paletteSel.addEventListener('change', ()=>{ currentPalette=paletteSel.value; localStorage.setItem('ovPalette',currentPalette); if(lastCells) rerenderSameData(); });

/* Overlay opacity + PNG */
document.getElementById('opacity').addEventListener('input', function(){ if(overlay) overlay.setOpacity(Number(this.value)/100); document.getElementById('ovv').textContent=this.value+'%'; });
document.getElementById('dlPng').addEventListener('click', ()=>{ if(!lastCanvas) return; const a=document.createElement('a'); a.download='overlay.png'; a.href=lastCanvas.toDataURL('image/png'); a.click(); });

/* Tiles scale (kept simple) */
const tileX=document.getElementById('tileX'), tileY=document.getElementById('tileY'), tileXVal=document.getElementById('tileXVal'), tileYVal=document.getElementById('tileYVal');
let tileScaleX=2, tileScaleY=2;
tileX.addEventListener('input', ()=>{ tileScaleX=Number(tileX.value)/100; tileXVal.textContent=tileX.value+'%'; if(lastCells) rerenderSameData(); });
tileY.addEventListener('input', ()=>{ tileScaleY=Number(tileY.value)/100; tileYVal.textContent=tileY.value+'%'; if(lastCells) rerenderSameData(); });

/* Legend */
const legendCtrl=L.control({position:'bottomright'});
legendCtrl.onAdd=function(){ const div=L.DomUtil.create('div','leaflet-control legend');
  div.innerHTML='<div id="legendTitle" style="font-weight:600;margin-bottom:4px">RR (mm)</div><canvas id="legendCanvas" width="240" height="12"></canvas><div class="legend-row"><span id="vminLabel">min</span><span id="vmaxLabel">max</span></div><div class="hint">0–98%</div>';
  L.DomEvent.disableClickPropagation(div); return div; }; legendCtrl.addTo(map);

function brighten(rgb, f=0.18){ return [ Math.round(rgb[0]+(255-rgb[0])*f), Math.round(rgb[1]+(255-rgb[1])*f), Math.round(rgb[2]+(255-rgb[2])*f) ]; }
function hex2rgb(h){ h=h.replace('#',''); return [parseInt(h.slice(0,2),16),parseInt(h.slice(2,4),16),parseInt(h.slice(4,6),16)]; }
function hslToRgb(h,s,l){ h=((h%360)+360)%360; s=Math.max(0,Math.min(1,s)); l=Math.max(0,Math.min(1,l)); const c=(1-Math.abs(2*l-1))*s, hp=h/60, x=c*(1-Math.abs(hp%2-1)); let r=0,g=0,b=0;
  if(hp<1){r=c;g=x;} else if(hp<2){r=x;g=c;} else if(hp<3){g=c;b=x;} else if(hp<4){g=x;b=c;} else if(hp<5){r=x;b=c;} else {r=c;b=x;} const m=l-c/2; return [Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];}
function stops(name){
  if(name==='viridis') return [[68,1,84],[72,30,110],[64,67,135],[55,90,140],[45,115,142],[37,137,141],[31,159,136],[43,183,122],[84,199,101],[129,211,78],[173,220,52],[212,225,33],[238,229,27],[247,229,32],[253,231,37]];
  if(name==='spectral'){ const s=['#9e0142','#d53e4f','#f46d43','#fdae61','#fee08b','#ffffbf','#e6f598','#abdda4','#66c2a5','#3288bd','#5e4fa2'].map(hex2rgb); return s; }
  if(name==='rainbow'){ const N=9, s=[]; for(let i=0;i<N;i++){ const t=i/(N-1), hue=260+(-280*t); s.push(hslToRgb(hue,1.0,0.56)); } return s; }
  return stops('spectral');
}
let STOPS = stops(currentPalette);
function colorForT(t){ t=Math.max(0,Math.min(1,t)); const idx=t*(STOPS.length-1), i=Math.floor(idx), j=Math.min(STOPS.length-1,i+1), local=idx-i;
  const c=[ Math.round(STOPS[i][0]+(STOPS[j][0]-STOPS[i][0])*local),
            Math.round(STOPS[i][1]+(STOPS[j][1]-STOPS[i][1])*local),
            Math.round(STOPS[i][2]+(STOPS[j][2]-STOPS[i][2])*local) ];
  const cc=brighten(c,0.18); return `rgb(${cc[0]},${cc[1]},${cc[2]})`;
}
function updateLegend(vmin,vmax){
  const c=document.getElementById('legendCanvas'); const ctx=c.getContext('2d'), w=c.width, h=c.height, img=ctx.createImageData(w,h);
  for(let x=0;x<w;x++){ const t=x/(w-1); const col=colorForT(t).match(/\d+/g).map(Number);
    for(let y=0;y<h;y++){ const i=(y*w+x)*4; img.data[i]=col[0]; img.data[i+1]=col[1]; img.data[i+2]=col[2]; img.data[i+3]=255; } }
  ctx.putImageData(img,0,0);
  document.getElementById('vminLabel').textContent=vmin.toFixed(1);
  document.getElementById('vmaxLabel').textContent=vmax.toFixed(1);
}

/*** Fetch + Render ***/
function parseValues(props, nt){
  const p=props||{}, key=PARAM;
  function norm(a){ const out=new Array(a.length); for(let i=0;i<a.length;i++){ let v=Number(a[i]); if(!isFinite(v)||v<=-9000) v=NaN; out[i]=v; } return out; }
  if(Array.isArray(p[key])) return norm(p[key]);
  if(p[key] && Array.isArray(p[key].values)) return norm(p[key].values);
  if(p[key] && Array.isArray(p[key].data))   return norm(p[key].data);
  if(p.values && Array.isArray(p.values[key]))return norm(p.values[key]);
  if(Array.isArray(p.data)) return norm(p.data);
  return null;
}
function bboxFromGeom(g){
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
  (function walk(n){ if(!n) return; if(Array.isArray(n)){ if(n.length>=2 && typeof n[0]==='number'){ const x=n[0], y=n[1];
    if(x<minx)minx=x; if(x>maxx)maxx=x; if(y<miny)miny=y; if(y>maxy)maxy=y; } else { for(const c of n) walk(c); } } })(g.coordinates);
  return [minx,miny,maxx,maxy];
}
function robustRange(vals){
  const a=vals.filter(v=>isFinite(v) && v>=0).sort((x,y)=>x-y);
  if(!a.length) return {vmin:0,vmax:1};
  const pos=(a.length-1)*0.98, lo=Math.floor(pos), hi=Math.ceil(pos), v98= a[lo]+(pos-lo)*(a[hi]-a[lo]);
  return {vmin:0, vmax: Math.max(1, v98)};
}
function renderCells(cells, bounds){
  const widthDeg=bounds.east-bounds.west, heightDeg=bounds.north-bounds.south;
  const PX_W=CANVAS_W, PX_H=Math.max(1,Math.round(PX_W*(heightDeg/widthDeg)));
  const cvs=document.createElement('canvas'); cvs.width=PX_W; cvs.height=PX_H; const ctx=cvs.getContext('2d'); ctx.imageSmoothingEnabled=false;

  const lonPerPx=widthDeg/PX_W, latPerPx=heightDeg/PX_H;
  const vals=cells.map(c=>c.v).filter(v=>isFinite(v)&&v>=0);
  const {vmin,vmax}=robustRange(vals); updateLegend(vmin,vmax);

  let drawn=0;
  for(const c of cells){
    if(!isFinite(c.v) || c.v<0) continue;
    const cx=0.5*(c.minx+c.maxx), cy=0.5*(c.miny+c.maxy);
    const cxpx=(cx-bounds.west)/lonPerPx, cypx=(bounds.north-cy)/latPerPx;
    // heuristische Zellgröße (1km~) + skaliert
    const dx=((c.maxx-c.minx)/lonPerPx)||4, dy=((c.maxy-c.miny)/latPerPx)||4;
    const halfW=Math.max(0.5, (dx*tileScaleX)/2), halfH=Math.max(0.5, (dy*tileScaleY)/2);
    let x=Math.floor(cxpx-halfW), y=Math.floor(cypx-halfH), w=Math.max(1,Math.ceil(halfW*2)), h=Math.max(1,Math.ceil(halfH*2));
    if(x+w<0||y+h<0||x>PX_W||y>PX_H) continue;
    if(x<0){w+=x;x=0;} if(y<0){h+=y;y=0;} if(x+w>PX_W){w=PX_W-x;} if(y+h>PX_H){h=PX_H-y;}
    const t=(c.v-vmin)/(vmax-vmin+1e-12); ctx.fillStyle=colorForT(Math.max(0,Math.min(1,t))); ctx.fillRect(x,y,w,h); drawn++;
  }
  return {canvas:cvs, drawn};
}
function placeOverlay(cvs){
  lastCanvas=cvs;
  const url=cvs.toDataURL('image/png');
  if(overlay) map.removeLayer(overlay);
  overlay=L.imageOverlay(url, baseBounds, overlayOptions).addTo(map);
}

/*** Auto-Run Pipeline ***/
async function autoRun(fit){
  try{
    warn('init','Init');
    progress(0.04);

    // 1) Dates
    let start = (startEl.value||'').trim(), end=(endEl.value||'').trim();
    if(!start || !end){ start=start14(); end=yesterday(); startEl.value=start; endEl.value=end; }
    ok('dates',`Datum ${start}→${end}`); progress(0.1);

    // 2) BBOX (parse + clamp)
    const parts=(document.getElementById('bbox').value||'').split(',').map(Number);
    let bbox = (parts.length===4 && parts.every(v=>isFinite(v))) ? parts : PRESETS.noe;
    const clamped = clampBBox(bbox);
    if (clamped.some((v,i)=>v!==bbox[i])) document.getElementById('bbox').value=clamped.join(',');
    const [south,west,north,east]=clamped;
    baseBoundsObj={south,west,north,east}; baseBounds=L.latLngBounds([south,west],[north,east]);
    ok('bbox',`BBOX ok`); progress(0.18);

    // 3) Fetch (mit Auto-Fix Wiederholung)
    const url=API+'?'+new URLSearchParams({parameters:PARAM,start,end,bbox:clamped.join(',')}).toString();
    let fc = await fetch(url,{headers:{Accept:'application/json'}}).then(async r=>{
      const txt=await r.text(); if(!r.ok) throw new Error(`HTTP ${r.status} ${txt}`); return JSON.parse(txt);
    }).catch(async e=>{
      // Einmaliger Retry: auf NOE fallback
      warn('fetch','Retry mit NÖ');
      const fallback=PRESETS.noe; document.getElementById('bbox').value=fallback.join(',');
      const url2=API+'?'+new URLSearchParams({parameters:PARAM,start,end,bbox:fallback.join(',')}).toString();
      return fetch(url2,{headers:{Accept:'application/json'}}).then(async r=>{
        const txt=await r.text(); if(!r.ok) throw new Error(`HTTP ${r.status} ${txt}`); return JSON.parse(txt);
      });
    });

    if(!fc || fc.type!=='FeatureCollection' || !Array.isArray(fc.features)) throw new Error('Ungültige Antwort');
    ok('fetch',`Fetch ok (${fc.features.length} features)`); progress(0.45);

    // 4) Cells bauen
    const ts=fc.timestamps||[], nt=ts.length;
    const cells=[];
    for(const f of fc.features){ const vals=parseValues(f.properties||{}, nt); if(!vals) continue;
      // 14-Tage Summe
      let s=0, okv=false; for(const v of vals){ const n=Number(v); if(isFinite(n)&&n>=0){s+=n; okv=true;} }
      if(!okv) continue;
      const bb=bboxFromGeom(f.geometry);
      cells.push({ v:s, minx:bb[0], miny:bb[1], maxx:bb[2], maxy:bb[3] });
    }
    lastCells=cells.slice(0);
    progress(0.62);

    // 5) Render (immer etwas zeigen)
    let out = renderCells(cells, baseBoundsObj);
    if(out.drawn===0){
      warn('draw','keine Pixel • Diagnose');
      // Diagnose-Gradient
      const widthDeg=east-west, heightDeg=north-south;
      const PX_W=CANVAS_W, PX_H=Math.max(1,Math.round(PX_W*(heightDeg/widthDeg)));
      const cvs=document.createElement('canvas'); cvs.width=PX_W; cvs.height=PX_H; const ctx=cvs.getContext('2d');
      for(let y=0;y<PX_H;y++){
        const t=y/(PX_H-1);
        ctx.fillStyle=colorForT(t);
        ctx.fillRect(0,y,PX_W,1);
      }
      out={canvas:cvs,drawn:1};
    } else {
      ok('draw','Render ok');
    }
    placeOverlay(out.canvas);
    if(fit) map.fitBounds(baseBounds.pad(0.1));
    progress(1);
    ok('init','Fertig');
  } catch(e){
    console.error(e);
    err('fetch','Fehler'); err('draw','Fehler');
    // Fallback: Schachbrett, damit nie „leer“
    const bb=(document.getElementById('bbox').value||'').split(',').map(Number);
    const [s,w,n,e]=clampBBox(bb.length===4?bb:PRESETS.noe);
    baseBoundsObj={south:s,west:w,north:n,east:e}; baseBounds=L.latLngBounds([s,w],[n,e]);
    const widthDeg=e-w, heightDeg=n-s;
    const PX_W=CANVAS_W, PX_H=Math.max(1,Math.round(PX_W*(heightDeg/widthDeg)));
    const cvs=document.createElement('canvas'); cvs.width=PX_W; cvs.height=PX_H; const ctx=cvs.getContext('2d');
    for(let y=0;y<PX_H;y+=32){ for(let x=0;x<PX_W;x+=32){ ctx.fillStyle=((x/32+y/32)%2===0)?'#ff0066':'#00aaff'; ctx.fillRect(x,y,32,32);} }
    placeOverlay(cvs);
    if(map && baseBounds) map.fitBounds(baseBounds.pad(0.1));
  }
}

function rerenderSameData(){
  if(!lastCells || !baseBoundsObj) return autoRun(false);
  const out = renderCells(lastCells, baseBoundsObj);
  placeOverlay(out.canvas);
}

/*** Debug Buttons ***/
document.getElementById('dbgPattern').addEventListener('click', ()=>{
  const bb=(document.getElementById('bbox').value||'').split(',').map(Number);
  const [s,w,n,e]=clampBBox(bb.length===4?bb:PRESETS.noe);
  baseBoundsObj={south:s,west:w,north:n,east:e}; baseBounds=L.latLngBounds([s,w],[n,e]);
  const widthDeg=e-w, heightDeg=n-s;
  const PX_W=CANVAS_W, PX_H=Math.max(1,Math.round(PX_W*(heightDeg/widthDeg)));
  const cvs=document.createElement('canvas'); cvs.width=PX_W; cvs.height=PX_H; const ctx=cvs.getContext('2d');
  for(let y=0;y<PX_H;y+=32){ for(let x=0;x<PX_W;x+=32){ ctx.fillStyle=((x/32+y/32)%2===0)?'#ff0066':'#00aaff'; ctx.fillRect(x,y,32,32);} }
  placeOverlay(cvs); map.fitBounds(baseBounds.pad(0.1));
});
document.getElementById('dbgCells').addEventListener('click', ()=>{
  if(!lastCells || !baseBoundsObj) return;
  const widthDeg=baseBoundsObj.east-baseBoundsObj.west, heightDeg=baseBoundsObj.north-baseBoundsObj.south;
  const PX_W=CANVAS_W, PX_H=Math.max(1,Math.round(PX_W*(heightDeg/widthDeg)));
  const cvs=document.createElement('canvas'); cvs.width=PX_W; cvs.height=PX_H; const ctx=cvs.getContext('2d'); const lonPerPx=widthDeg/PX_W, latPerPx=heightDeg/PX_H;
  let i=0; for(const c of lastCells){
    const cx=0.5*(c.minx+c.maxx), cy=0.5*(c.miny+c.maxy);
    const cxpx=(cx-baseBoundsObj.west)/lonPerPx, cypx=(baseBoundsObj.north-cy)/latPerPx;
    const hue=(i*47)%360; // hübsch bunt
    const col=hslToRgb(hue,0.9,0.55); ctx.fillStyle=`rgb(${col[0]},${col[1]},${col[2]})`;
    ctx.fillRect(Math.floor(cxpx-4), Math.floor(cypx-4), 8, 8); i++;
  }
  placeOverlay(cvs);
});

/*** Auto-Start ***/
window.addEventListener('load', ()=> {
  warn('init','Init'); warn('bbox','BBOX'); warn('dates','Datum'); warn('fetch','Fetch'); warn('draw','Render');
  setTimeout(()=> autoRun(true), 120);
});
</script>
</body>
</html>
