<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoSphere Niederschlagssumme (SPARTACUS)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
        }
        #map {
            flex: 1;
            height: 100%;
        }
        #sidebar {
            width: 380px; /* Breiter für Debug-Infos */
            padding: 20px;
            background-color: #f4f4f4;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        h2 {
            margin-top: 0;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        input[type="text"], input[type="date"], select, button {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            cursor: pointer;
            font-weight: bold;
            color: white;
            border: none;
        }
        button:disabled {
            background-color: #ccc !important;
            cursor: not-allowed;
        }
        #btnRender {
            background-color: #4CAF50;
        }
        #btnRender:hover:not(:disabled) {
            background-color: #45a049;
        }
        #btnExport {
            background-color: #0078A8;
        }
        #btnExport:hover:not(:disabled) {
            background-color: #005a75;
        }
        .preset-buttons {
            display: flex;
            gap: 10px;
        }
        .preset-buttons button {
            flex: 1;
            background-color: #e0e0e0;
            color: black;
        }
        
        /* Status Area Styling - Optimiert für Debugging */
        #status {
            font-size: 0.85em;
            color: #333;
            word-break: break-word; /* Um lange URLs/Koordinaten umzubrechen */
            white-space: pre-wrap; /* Wichtig für Zeilenumbrüche in Debug-Info */
            max-height: 200px;
            overflow-y: auto;
            background-color: #fff;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace; /* Bessere Lesbarkeit */
        }

        #progress-container {
            background-color: #ddd;
            border-radius: 4px;
            overflow: hidden;
            height: 20px;
            margin-top: 5px;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            text-align: center;
            line-height: 20px;
            color: white;
            transition: width 0.3s;
            font-size: 0.8em;
        }

        #legend {
            margin-top: 15px;
            padding: 10px;
            background: white;
            border-radius: 4px;
        }
        #legend-canvas {
            width: 100%;
            height: 25px;
            border-radius: 4px;
        }
        #legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            margin-top: 5px;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>Niederschlagssumme (SPARTACUS)</h2>

    <div class="control-group">
        <label>Zeitraum</label>
        <label for="dateStart" style="font-weight: normal;">Von:</label>
        <input type="date" id="dateStart">
        <label for="dateEnd" style="font-weight: normal;">Bis (inklusive):</label>
        <input type="date" id="dateEnd">
    </div>

    <div class="control-group">
        <label for="bbox">BBOX (lat_min, lon_min, lat_max, lon_max)</label>
        <input type="text" id="bbox" placeholder="Süden, Westen, Norden, Osten">
        <div class="preset-buttons">
            <button onclick="setBboxPreset('NOE')">NÖ</button>
            <button onclick="setBboxPreset('STMK')">Steiermark</button>
        </div>
    </div>

    <div class="control-group">
        <label for="palette">Farbpalette</label>
        <select id="palette" onchange="handlePaletteChange()">
            <option value="viridis">Viridis</option>
            <option value="spectral">Spectral</option>
            <option value="rainbow">Rainbow</option>
        </select>
    </div>

    <div class="control-group">
        <label for="opacity">Deckkraft: <span id="opacityValue">75%</span></label>
        <input type="range" id="opacity" min="0" max="1" step="0.01" value="0.75" oninput="updateOpacity(this.value)">
    </div>

    <button id="btnRender" onclick="renderPrecipitation()" disabled>Rendern</button>
    <button id="btnExport" onclick="exportPNG()" disabled>Als PNG exportieren</button>

    <div class="control-group">
        <label>Status & Debug Info</label>
        <div id="status">Initialisiere...</div>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
    </div>

    <div id="legend">
        <label>Legende (mm, 0-98% Skala)</label>
        <canvas id="legend-canvas"></canvas>
        <div id="legend-labels">
            <span id="legend-min">0.0</span>
            <span id="legend-max">-</span>
        </div>
    </div>
</div>

<div id="map"></div>

<script>
    // --- Configuration ---
    const API_HOST = 'https://dataset.api.hub.geosphere.at';
    const DATASET_ENDPOINT = '/v1/grid/historical/spartacus-v2-1d-1km';
    const PARAMETER = 'RR'; // Niederschlag
    
    // Robustheit: Epsilon (Sicherheitsabstand) für Clamping.
    // Erhöht auf 0.009 Grad (ca. 1km oder eine Pixelbreite), um strikte API-Validierung sicher zu bestehen.
    const CLAMP_EPSILON = 0.009; 

    // Dokumentierte Grenzen (Fallback).
    const DOCUMENTED_EXTENT = {
        lat_min: 46.37, lon_min: 9.53, lat_max: 49.02, lon_max: 17.16
    };
    // Plausibilitätsgrenzen für Österreich (zur Validierung der Metadaten-Interpretation)
    const AUSTRIA_PLAUSIBILITY = {
        lat_min: 46.0, lon_min: 9.0, lat_max: 50.0, lon_max: 18.0
    };

    const BBOX_PRESETS = {
        // Niederösterreich (lat_min, lon_min, lat_max, lon_max).
        NOE: '47.419564822,14.450844322,49.024548178,17.075640678',
        // Steiermark.
        STMK: '46.35,13.55,47.75,16.51'
    };
    const MISSING_VALUE = -9999;

    // --- Global State ---
    let map;
    let precipitationOverlay = null;
    let currentCanvas = null;
    let currentData = null;
    let isLoading = false;
    let DATASET_BOUNDS = null; 
    let DATASET_TEMPORAL = null;
    let isInitialized = false;

    // --- Initialization & Metadata Fetching ---
    
    async function initialize() {
        if (isInitialized) return;
        isInitialized = true;

        initMap();
        initUI(); 
        updateLegend(0, 100); 
        
        await fetchMetadata();
    }

    // Hilfsfunktion zur Plausibilitätsprüfung von Koordinaten
    const isPlausible = (lat_min, lon_min, lat_max, lon_max) => {
        // Prüft, ob die Grenzen innerhalb der Plausibilitätsgrenzen liegen UND ob min < max ist.
        const true_lat_min = Math.min(lat_min, lat_max);
        const true_lat_max = Math.max(lat_min, lat_max);
        const true_lon_min = Math.min(lon_min, lon_max);
        const true_lon_max = Math.max(lon_min, lon_max);

        return true_lat_min >= AUSTRIA_PLAUSIBILITY.lat_min && true_lat_max <= AUSTRIA_PLAUSIBILITY.lat_max &&
               true_lon_min >= AUSTRIA_PLAUSIBILITY.lon_min && true_lon_max <= AUSTRIA_PLAUSIBILITY.lon_max;
    };

    async function fetchMetadata() {
        updateStatus('DEBUG: Starte Metadaten-Abruf...', 0);
        setLoadingState(true);

        try {
            const response = await fetch(`${API_HOST}${DATASET_ENDPOINT}/metadata`);
            if (!response.ok) {
                throw new Error(`Metadaten API Fehler: ${response.status}`);
            }
            const metadata = await response.json();

            // 1. Parse Spatial BBOX Robustly
            const bbox = metadata.bbox;
            if (!bbox || bbox.length !== 4 || bbox.some(isNaN)) {
                throw new Error("Ungültige BBOX in Metadaten.");
            }

            let interpretation = null;

            // Interpretation 1: W,S,E,N [lon_min, lat_min, lon_max, lat_max] (Standard GeoJSON/OGC)
            if (isPlausible(bbox[1], bbox[0], bbox[3], bbox[2])) {
                interpretation = { lat_min: bbox[1], lon_min: bbox[0], lat_max: bbox[3], lon_max: bbox[2] };
                console.log("Metadata BBOX interpreted as W,S,E,N (Standard).");
            } 
            // Interpretation 2: S,W,N,E [lat_min, lon_min, lat_max, lon_max]
            else if (isPlausible(bbox[0], bbox[1], bbox[2], bbox[3])) {
                interpretation = { lat_min: bbox[0], lon_min: bbox[1], lat_max: bbox[2], lon_max: bbox[3] };
                console.warn("Metadata BBOX interpreted as S,W,N,E (Non-standard).");
            } else {
                 throw new Error("Metadata BBOX interpretation failed. Coordinates implausible. Raw BBOX: " + bbox.join(','));
            }
            
            // Sicherstellen der internen Konsistenz (min < max)
            DATASET_BOUNDS = {
                lat_min: Math.min(interpretation.lat_min, interpretation.lat_max),
                lon_min: Math.min(interpretation.lon_min, interpretation.lon_max),
                lat_max: Math.max(interpretation.lat_min, interpretation.lat_max),
                lon_max: Math.max(interpretation.lon_min, interpretation.lon_max)
            };
            
            
            // Erstelle detaillierte Debug-Nachricht für die Initialisierung
            const fmt = (n) => n.toFixed(6);
            const debugMsg = `DEBUG: Metadaten geladen.\nAPI Raw BBOX:\n[${bbox.map(fmt).join(', ')}]\n\nInterpretiert (S,W,N,E):\n[${fmt(DATASET_BOUNDS.lat_min)}, ${fmt(DATASET_BOUNDS.lon_min)}, ${fmt(DATASET_BOUNDS.lat_max)}, ${fmt(DATASET_BOUNDS.lon_max)}]\nEpsilon: ${CLAMP_EPSILON}`;
            console.log(debugMsg);

            // 2. Parse Temporal Extent
            if (metadata.temporal_extent && metadata.temporal_extent.interval && metadata.temporal_extent.interval.length > 0) {
                const interval = metadata.temporal_extent.interval[0];
                if (interval.length === 2) {
                    const startDate = interval[0] ? new Date(interval[0]) : null;
                    const endDate = interval[1] ? new Date(interval[1]) : new Date();

                    if (startDate && endDate && startDate < endDate) {
                        DATASET_TEMPORAL = { start: startDate, end: endDate };
                    }
                }
            }

            // UI aktualisieren (Zeitraum anpassen)
            initUI(DATASET_TEMPORAL);

            updateStatus('Bereit.\n\n' + debugMsg, 0);

        } catch (error) {
            console.error("Metadata fetch failed:", error);
            DATASET_BOUNDS = DOCUMENTED_EXTENT; // Use fallback
            updateStatus('WARNUNG: Metadaten konnten nicht geladen werden. Nutze Fallback-Grenzen. Details: ' + error.message, 0);
        } finally {
            setLoadingState(false);
        }
    }

    function initMap() {
        map = L.map('map').setView([47.7, 15.0], 8);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> | Daten: <a href="https://geosphere.at">GeoSphere Austria</a> (SPARTACUS)'
        }).addTo(map);
    }

    function initUI(temporalBounds = null) {
        // Default: letzte 14 Tage bis gestern
        let today = new Date();
        today.setHours(12, 0, 0, 0);
        
        // Robustheit: Adjustiere Datum, falls außerhalb der Verfügbarkeit.
        if (temporalBounds && temporalBounds.end && today > temporalBounds.end) {
            today = new Date(temporalBounds.end.getTime());
            // Handle T00:00:00Z end dates by stepping back one day
            if (today.getUTCHours() === 0 && today.getUTCMinutes() === 0 && today.getUTCSeconds() === 0) {
                 today.setUTCDate(today.getUTCDate() - 1);
            }
            today.setHours(12, 0, 0, 0);
        }

        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        const fourteenDaysAgo = new Date(today);
        fourteenDaysAgo.setDate(today.getDate() - 14);

        const formatDate = (date) => date.toISOString().split('T')[0];

        document.getElementById('dateEnd').value = formatDate(yesterday);
        document.getElementById('dateStart').value = formatDate(fourteenDaysAgo);

        const currentBbox = document.getElementById('bbox').value;
        if (!currentBbox || Object.values(BBOX_PRESETS).includes(currentBbox)) {
            setBboxPreset('NOE');
        }
    }

    // --- UI Helpers & Event Handlers ---
    
    // Hilfsfunktion zum Kopieren in die Zwischenablage (synchroner Fallback)
    function copyToClipboardSync(text) {
        // Nutzt document.execCommand (deprecated, aber weit unterstützt für synchrone Aktionen im Browser)
        try {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.opacity = "0";

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            return successful;
        } catch (err) {
            console.error("Synchronous copy failed: ", err);
            return false;
        }
    }

    function setBboxPreset(preset) {
        const bboxStr = BBOX_PRESETS[preset];
        document.getElementById('bbox').value = bboxStr;
        const bbox = bboxStr.split(',').map(Number);
        if (bbox.length === 4 && !bbox.some(isNaN)) {
             try {
                // Input format: lat_min, lon_min, lat_max, lon_max
                map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]]);
             } catch (e) {
                 console.error("Invalid preset bounds:", e);
             }
        }
    }

    function updateOpacity(value) {
        document.getElementById('opacityValue').textContent = Math.round(value * 100) + '%';
        if (precipitationOverlay) {
            precipitationOverlay.setOpacity(value);
        }
    }

    function updateStatus(message, progress) {
        document.getElementById('status').textContent = message;
        const progressBar = document.getElementById('progress-bar');
        if (progress !== undefined) {
            progressBar.style.width = progress + '%';
            progressBar.textContent = progress > 5 ? progress + '%' : '';
        } else {
             progressBar.style.width = '0%';
             progressBar.textContent = '';
        }
    }

    function setLoadingState(loading) {
        isLoading = loading;
        
        const boundsLoaded = DATASET_BOUNDS !== null;
        document.getElementById('btnRender').disabled = isLoading || !boundsLoaded;
        
        if (isLoading) {
            document.getElementById('btnExport').disabled = true;
        }
        
        if (!isLoading && boundsLoaded) {
            setTimeout(() => {
                const pb = document.getElementById('progress-bar');
                const statusText = document.getElementById('status').textContent;
                if (pb.style.width !== '100%' && statusText.indexOf('Fertig') === -1) {
                   // Detaillierte Fehlermeldungen (mit Debug Info) sichtbar lassen.
                   if (statusText.indexOf('Bereit') === -1 && statusText.indexOf('WARNUNG') === -1 && statusText.indexOf('Debug Info') === -1) {
                        updateStatus(statusText, 0);
                   }
                }
            }, 500);
        }
    }

    function handlePaletteChange() {
        if (currentData) {
            try {
                updateStatus('Aktualisiere Palette...', 90);
                const { canvas, minValue, maxValue } = renderCanvas(currentData);
                updateMapOverlay(canvas, currentData.bounds, true);
                updateLegend(minValue, maxValue);
                updateStatus('Fertig (Palette aktualisiert).', 100);
            } catch (error) {
                console.error("Fehler beim Re-Rendering mit neuer Palette:", error);
                updateStatus('Fehler beim Palette-Update.', 0);
            }
        } else {
            updateLegend(0, 100);
        }
    }

    // --- Core Logic ---
    async function renderPrecipitation() {
        if (isLoading || !DATASET_BOUNDS) {
            return;
        }

        setLoadingState(true);
        updateStatus('Vorbereitung...', 5);
        
        if (precipitationOverlay) {
            map.removeLayer(precipitationOverlay);
            precipitationOverlay = null;
        }
        currentData = null; 

        const start = document.getElementById('dateStart').value;
        const end = document.getElementById('dateEnd').value;
        let bboxInput = document.getElementById('bbox').value;

        if (!start || !end || !bboxInput) {
            alert("Bitte Zeitraum und Bounding Box angeben.");
            updateStatus('Fehler: Ungültige Eingabe.', 0);
            setLoadingState(false);
            return;
        }

        let clampedBboxArray;
        let requestUrl = '';
        
        try {
            // 1. Validate Temporal Range
            if (DATASET_TEMPORAL) {
                const requestedStart = new Date(start + 'T12:00:00Z');
                const requestedEnd = new Date(end + 'T12:00:00Z');

                if (requestedEnd < DATASET_TEMPORAL.start || requestedStart > DATASET_TEMPORAL.end) {
                    const availableStart = DATASET_TEMPORAL.start.toISOString().split('T')[0];
                    const availableEnd = DATASET_TEMPORAL.end.toISOString().split('T')[0];
                    throw new Error(`Zeitraum ungültig. Verfügbar: ${availableStart} bis ${availableEnd}.`);
                }
            }

            // 2. Clamp BBOX
            // Dies kann einen Fehler werfen, wenn die BBOX vollständig außerhalb liegt (inkl. Debug-Info).
            clampedBboxArray = clampBbox(bboxInput);
            
            document.getElementById('bbox').value = clampedBboxArray.join(',');
            updateStatus('BBOX geklammert. Lade Daten von GeoSphere API...', 10);

            // 3. Fetch Data
            requestUrl = buildApiUrl(start, end, clampedBboxArray);

            console.log("Request URL:", requestUrl);
            const response = await fetch(requestUrl);
            
            if (!response.ok) {
                const errorDetailsRaw = await response.text().catch(() => 'Keine Details verfügbar.');
                let apiErrorDetail = errorDetailsRaw.substring(0, 200);
                let isBboxError = false;

                try {
                    const errorJson = JSON.parse(errorDetailsRaw);
                    if (errorJson.detail) {
                        apiErrorDetail = errorJson.detail;
                        // Prüfe auf den spezifischen Fehler, der gemeldet wurde
                        if (apiErrorDetail.includes("outside of dataset bounds")) {
                            isBboxError = true;
                        }
                    }
                } catch (e) { /* Not JSON */ }

                // Wenn die API die BBOX ablehnt (trotz Clamping): Detailliertes Debugging.
                // Wir behandeln HTTP 400 generell als potentiellen BBOX Fehler in diesem Kontext.
                if (isBboxError || response.status === 400) {
                    const fmt = (n) => n.toFixed(6);
                    const debugInfo = `\n\n--- API Error Debug Info ---\n` +
                                      `Status: ${response.status}\n` +
                                      `API Response: ${apiErrorDetail}\n\n` +
                                      (isBboxError ? `!! API hat die Anfrage trotz Clamping abgelehnt (Outside Bounds) !!\n\n` : "") +
                                      `Requested Clamped BBOX (S,W,N,E):\n[${clampedBboxArray.map(fmt).join(', ')}]\n\n` +
                                      `Dataset Bounds (S,W,N,E):\n[${fmt(DATASET_BOUNDS.lat_min)}, ${fmt(DATASET_BOUNDS.lon_min)}, ${fmt(DATASET_BOUNDS.lat_max)}, ${fmt(DATASET_BOUNDS.lon_max)}]\n\n` +
                                      `Epsilon: ${CLAMP_EPSILON.toFixed(6)}\n\n` +
                                      `Full Request URL:\n${requestUrl}`;

                    // Copy to clipboard
                    const copySuccess = copyToClipboardSync(debugInfo);
                    const clipboardMsg = copySuccess ? "\n\n(Debug Info in Zwischenablage kopiert.)" : "";

                    throw new Error(`API Fehler aufgetreten.` + debugInfo + clipboardMsg);
                }
                
                // Andere API Fehler
                throw new Error(`API Fehler ${response.status}: ${apiErrorDetail}`);
            }
            
            updateStatus('Daten empfangen, verarbeite GeoJSON...', 40);
            const geojsonData = await response.json();

            // 4. Process Data
            updateStatus('Aggregiere Niederschlagsdaten (Summe)...', 60);
            const processedData = processApiData(geojsonData);
            currentData = processedData;

            // 5. Render Data
            updateStatus('Rendere Canvas...', 85);
            const { canvas, minValue, maxValue } = renderCanvas(processedData);
            
            // 6. Update Map and Legend
            updateMapOverlay(canvas, processedData.bounds);
            updateLegend(minValue, maxValue);

            updateStatus('Fertig.', 100);
            document.getElementById('btnExport').disabled = false;

        } catch (error) {
            console.error("Fehler beim Rendern:", error);
            // Display error (enthält bereits Debug-Info, falls von clampBbox oder API-Fetch geworfen)
            let errorMessage = 'Fehler: ' + error.message;
            updateStatus(errorMessage, 0);
            
            // Robustheit: Fallback rendern
            let fallbackBbox = clampedBboxArray;
            if (!fallbackBbox) {
                try {
                    const bbox = bboxInput.split(',').map(s => parseFloat(s.trim()));
                    if (bbox.length === 4 && !bbox.some(isNaN)) {
                        fallbackBbox = bbox;
                    }
                } catch (e) { /* ignore parsing errors */ }
            }
            renderFallback(fallbackBbox);
        } finally {
            setLoadingState(false);
        }
    }

    // --- BBOX Clamping ---
    // Robustheit: BBOX an Dataset-Grenzen clampen.
    function clampBbox(bboxString) {
        if (!DATASET_BOUNDS) {
            throw new Error("Systemfehler: Dataset-Grenzen sind noch nicht verfügbar.");
        }

        const bbox = bboxString.split(',').map(s => parseFloat(s.trim()));
        // Expects lat_min, lon_min, lat_max, lon_max
        if (bbox.length !== 4 || bbox.some(isNaN)) {
            throw new Error("Ungültiges BBOX Format (erwartet: lat_min, lon_min, lat_max, lon_max).");
        }

        let [lat_min, lon_min, lat_max, lon_max] = bbox;

        if (lat_min > lat_max) [lat_min, lat_max] = [lat_max, lat_min];
        if (lon_min > lon_max) [lon_min, lon_max] = [lon_max, lon_min];

        // Define safe boundaries by applying Epsilon
        const SAFE_LAT_MIN = DATASET_BOUNDS.lat_min + CLAMP_EPSILON;
        const SAFE_LON_MIN = DATASET_BOUNDS.lon_min + CLAMP_EPSILON;
        const SAFE_LAT_MAX = DATASET_BOUNDS.lat_max - CLAMP_EPSILON;
        const SAFE_LON_MAX = DATASET_BOUNDS.lon_max - CLAMP_EPSILON;

        // Clamp the input BBOX
        const clamped_lat_min = Math.max(lat_min, SAFE_LAT_MIN);
        const clamped_lon_min = Math.max(lon_min, SAFE_LON_MIN);
        const clamped_lat_max = Math.min(lat_max, SAFE_LAT_MAX);
        const clamped_lon_max = Math.min(lon_max, SAFE_LON_MAX);

        // Ensure clamped bbox is still valid (not inverted after clamping).
        if (clamped_lat_min >= clamped_lat_max || clamped_lon_min >= clamped_lon_max) {
             console.warn("Requested BBOX is entirely outside the dataset extent.");
             
             // Detaillierte Debug-Informationen bereitstellen.
             const fmt = (n) => n.toFixed(6); 
             // Format: (S,W,N,E) = (LatMin, LonMin, LatMax, LonMax)
             const debugInfo = `\n\n--- Clamping Debug Info (S,W,N,O) ---\n` +
                               `Input BBOX:\n[${fmt(lat_min)}, ${fmt(lon_min)}, ${fmt(lat_max)}, ${fmt(lon_max)}]\n\n` +
                               `Dataset Bounds (Ermittelt):\n[${fmt(DATASET_BOUNDS.lat_min)}, ${fmt(DATASET_BOUNDS.lon_min)}, ${fmt(DATASET_BOUNDS.lat_max)}, ${fmt(DATASET_BOUNDS.lon_max)}]\n\n` +
                               `Safe Bounds (inkl. Epsilon ${CLAMP_EPSILON.toFixed(6)}):\n[${fmt(SAFE_LAT_MIN)}, ${fmt(SAFE_LON_MIN)}, ${fmt(SAFE_LAT_MAX)}, ${fmt(SAFE_LON_MAX)}]`;

            const errorMessage = "Die angeforderte BBOX liegt vollständig außerhalb des Dataset-Bereichs.";
            const fullErrorText = errorMessage + debugInfo;

            // Kopiere in Zwischenablage
            const copySuccess = copyToClipboardSync(fullErrorText);
             
            let clipboardMsg = copySuccess
                ? "\n\n(Debug Info wurde automatisch in die Zwischenablage kopiert.)"
                : "\n\n(Automatisches Kopieren fehlgeschlagen.)";

             throw new Error(fullErrorText + clipboardMsg);
        }

        // Runden auf 6 Nachkommastellen
        return [clamped_lat_min, clamped_lon_min, clamped_lat_max, clamped_lon_max].map(v => parseFloat(v.toFixed(6)));
    }

    // --- API Interaction ---
    function buildApiUrl(start, end, bboxArray) {
        // GeoSphere API erwartet BBOX in W,S,E,N Reihenfolge (lon_min, lat_min, lon_max, lat_max)
        const lon_min = bboxArray[1].toFixed(6);
        const lat_min = bboxArray[0].toFixed(6);
        const lon_max = bboxArray[3].toFixed(6);
        const lat_max = bboxArray[2].toFixed(6);
        
        const bboxWsen = `${lon_min},${lat_min},${lon_max},${lat_max}`;

        const params = new URLSearchParams({
            parameters: PARAMETER,
            start: start + 'T00:00:00Z',
            end: end + 'T23:59:59Z', 
            bbox: bboxWsen,
            crs: '4326' 
        });
        return `${API_HOST}${DATASET_ENDPOINT}?${params.toString()}`;
    }

    // --- Data Processing ---
    function processApiData(geojsonData) {
        if (!geojsonData || geojsonData.type !== 'FeatureCollection' || !geojsonData.features || geojsonData.features.length === 0) {
            throw new Error("Keine Daten im API Response gefunden (leere FeatureCollection).");
        }

        // 1. Determine grid dimensions
        const lats = new Set();
        const lons = new Set();
        const coordKey = (coord) => coord.toFixed(8);

        geojsonData.features.forEach(feature => {
            if (feature.geometry && feature.geometry.type === 'Point') {
                // GeoJSON coordinates are [Longitude, Latitude]
                const coords = feature.geometry.coordinates;
                lons.add(coordKey(coords[0]));
                lats.add(coordKey(coords[1]));
            }
        });

        // 2. Sort coordinates (North to South, West to East)
        const sortedLats = Array.from(lats).map(Number).sort((a, b) => b - a);
        const sortedLons = Array.from(lons).map(Number).sort((a, b) => a - b);

        const height = sortedLats.length;
        const width = sortedLons.length;

        // 3. Initialize grid and lookup maps
        const gridData = Array(height).fill(0).map(() => Array(width).fill(0));
        const validValues = [];
        const latIndexMap = new Map(sortedLats.map((lat, index) => [coordKey(lat), index]));
        const lonIndexMap = new Map(sortedLons.map((lon, index) => [coordKey(lon), index]));

        // 4. Aggregate data
        geojsonData.features.forEach(feature => {
            if (!feature.geometry || feature.geometry.type !== 'Point') return;

            const coords = feature.geometry.coordinates;
            const rowIndex = latIndexMap.get(coordKey(coords[1]));
            const colIndex = lonIndexMap.get(coordKey(coords[0]));

            if (rowIndex !== undefined && colIndex !== undefined) {
                const props = feature.properties;
                let timeSeries = (props && props.data && props.data[PARAMETER]) ? props.data[PARAMETER] : null;

                let sum = 0;
                
                if (timeSeries && Array.isArray(timeSeries)) {
                    // Aggregation: Summe, negative/fehlende Werte ignorieren
                    timeSeries.forEach(value => {
                        if (value !== null && value >= 0 && value !== MISSING_VALUE) {
                            sum += value;
                        }
                    });
                }
                
                gridData[rowIndex][colIndex] = sum;
                if (sum > 0) {
                    validValues.push(sum);
                }
            }
        });

        // 5. Calculate precise bounds for ImageOverlay
        // Verwende 0.009 als Näherung für 1km (passend zu Epsilon), falls nur eine Zeile/Spalte vorhanden ist.
        let latStep = height > 1 ? Math.abs(sortedLats[0] - sortedLats[1]) : 0.009; 
        let lonStep = width > 1 ? Math.abs(sortedLons[0] - sortedLons[1]) : (0.009 / Math.cos(sortedLats[0] * Math.PI / 180));

        // Bounds [SW corner, NE corner]
        const bounds = L.latLngBounds(
            [sortedLats[height - 1] - latStep / 2, sortedLons[0] - lonStep / 2], // SW
            [sortedLats[0] + latStep / 2, sortedLons[width - 1] + lonStep / 2]  // NE
        );

        return { gridData, width, height, validValues, bounds };
    }

    // Helper to calculate percentile
    function calculatePercentile(data, percentile) {
        if (data.length === 0) return 0;
        const sortedData = [...data].sort((a, b) => a - b);
        const index = Math.ceil(percentile * sortedData.length) - 1;
        return sortedData[Math.max(0, index)];
    }

    // --- Visualization (Canvas Rendering) ---
    function renderCanvas(processedData) {
        const { gridData, width, height, validValues } = processedData;
        const paletteName = document.getElementById('palette').value;
        const colorFunc = getColorFunction(paletteName);

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(width, height);
        const imgData = imageData.data;

        // Darstellung: 0–98%-Skalierung (robuste Range)
        const minValue = 0;
        let maxValue = calculatePercentile(validValues, 0.98);

        if (maxValue <= 0 && validValues.length > 0) {
             maxValue = Math.max(...validValues);
        } 
        
        if (maxValue <= 0) {
            maxValue = 1;
        }
        
        const range = maxValue - minValue;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const value = gridData[y][x];
                const index = (y * width + x) * 4;

                if (value > 0) {
                    const normalized = Math.min(1, Math.max(0, (value - minValue) / range));
                    const color = colorFunc(normalized);

                    imgData[index] = color[0];     // R
                    imgData[index + 1] = color[1]; // G
                    imgData[index + 2] = color[2]; // B
                    imgData[index + 3] = 255;      // A
                } else {
                    imgData[index + 3] = 0;
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);
        return { canvas, minValue, maxValue };
    }

    // --- Map Integration ---
    function updateMapOverlay(canvas, bounds, skipFitBounds = false) {
        if (precipitationOverlay) {
            map.removeLayer(precipitationOverlay);
        }

        currentCanvas = canvas;
        const opacity = document.getElementById('opacity').value;

        // Darstellung: Canvas → Leaflet ImageOverlay (keine Blend-Modes)
        precipitationOverlay = L.imageOverlay(canvas.toDataURL(), bounds, {
            opacity: opacity,
            interactive: false
        }).addTo(map);

        if (!skipFitBounds) {
             map.fitBounds(bounds, { padding: [10, 10] });
        }
    }

    // --- Legend ---
    function updateLegend(min, max) {
        document.getElementById('legend-min').textContent = min.toFixed(1);
        
        if (typeof max === 'number') {
             document.getElementById('legend-max').textContent = max.toFixed(1) + '+';
        } else {
            document.getElementById('legend-max').textContent = max;
        }

        const canvas = document.getElementById('legend-canvas');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        
        if (rect.width > 0 && rect.height > 0) {
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
        } else {
            canvas.width = (canvas.clientWidth || 280) * dpr;
            canvas.height = (canvas.clientHeight || 25) * dpr;
        }

        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        ctx.clearRect(0, 0, width, height);

        const gradient = ctx.createLinearGradient(0, 0, width, 0);
        const paletteName = document.getElementById('palette').value;
        const colorFunc = getColorFunction(paletteName);

        const steps = 50;
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const color = colorFunc(t);
            gradient.addColorStop(t, `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
    }

    // --- Robustness & Fallback ---
    // Robustheit: bei Fehlern ein Schachbrett-Fallback rendern
    function renderFallback(bboxArray) {
        if (!Array.isArray(bboxArray) || bboxArray.length !== 4) {
            updateLegend(0, '-');
            return;
        }
        
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');

        // Draw checkerboard pattern
        const tileSize = 16;
        ctx.fillStyle = '#ffffff'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f0f0f0'; 

        for (let y = 0; y < canvas.height; y += tileSize) {
            for (let x = 0; x < canvas.width; x += tileSize) {
                if ((Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2 === 0) {
                    ctx.fillRect(x, y, tileSize, tileSize);
                }
            }
        }
        
        // Add text
        ctx.fillStyle = '#D32F2F';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Fehler beim Laden/Rendern', canvas.width / 2, canvas.height / 2 - 10);
        ctx.font = '14px sans-serif';
        ctx.fillText('Details siehe Status/Konsole', canvas.width / 2, canvas.height / 2 + 15);

        if (bboxArray[0] < bboxArray[2] && bboxArray[1] < bboxArray[3]) {
             const bounds = L.latLngBounds(
                [bboxArray[0], bboxArray[1]],
                [bboxArray[2], bboxArray[3]]
            );
            updateMapOverlay(canvas, bounds, true); // skipFitBounds = true
        }
       
        updateLegend(0, '-');
    }

    // --- Export ---
    function exportPNG() {
        if (!currentCanvas) return;

        const start = document.getElementById('dateStart').value;
        const end = document.getElementById('dateEnd').value;
        const filename = `Niederschlagssumme_SPARTACUS_${start}_bis_${end}.png`;

        const link = document.createElement('a');
        link.download = filename;
        link.href = currentCanvas.toDataURL('image/png');
        link.click();
    }

    // --- Color Palettes Implementation ---

    function getColorFunction(name) {
        switch (name) {
            case 'spectral': return colorSpectral;
            case 'rainbow': return colorRainbow;
            case 'viridis':
            default: return colorViridis;
        }
    }

    // Helper for color interpolation
    function interpolateColor(c1, c2, t) {
        return [
            Math.round(c1[0] * (1 - t) + c2[0] * t),
            Math.round(c1[1] * (1 - t) + c2[1] * t),
            Math.round(c1[2] * (1 - t) + c2[2] * t)
        ];
    }

    // Simple Rainbow
    function colorRainbow(t) {
        const hue = (1 - t) * 240;
        return hslToRgb(hue / 360, 0.9, 0.5);
    }

    // Simple Spectral
    function colorSpectral(t) {
        if (t < 0.25) { // Blue to Cyan
             return interpolateColor([0, 0, 255], [0, 255, 255], t / 0.25);
        } else if (t < 0.5) { // Cyan to Green
            return interpolateColor([0, 255, 255], [0, 200, 0], (t - 0.25) / 0.25);
        } else if (t < 0.75) { // Green to Yellow
            return interpolateColor([0, 200, 0], [255, 255, 0], (t - 0.5) / 0.25);
        } else { // Yellow to Red
            return interpolateColor([255, 255, 0], [255, 0, 0], (t - 0.75) / 0.25);
        }
    }

    // Viridis implementation using Lookup Table
    const VIRIDIS_DATA = [
        [68,1,84],[68,2,84],[68,2,85],[68,3,85],[68,4,86],[68,5,86],[68,6,87],[68,7,88],[68,8,88],[68,9,89],[69,10,90],[69,11,90],[69,12,91],[69,13,92],[69,14,93],[69,15,93],[69,16,94],[69,17,95],[69,18,96],[69,19,97],[69,20,98],[69,21,98],[69,22,99],[69,23,100],[69,24,101],[69,26,102],[69,27,103],[69,28,104],[68,29,105],[68,30,106],[68,31,107],[68,32,107],[68,33,108],[68,34,109],[67,35,110],[67,36,111],[67,37,112],[66,38,113],[66,39,114],[66,40,115],[65,41,116],[65,42,116],[65,43,117],[64,44,118],[64,45,119],[64,46,120],[63,47,121],[63,48,121],[62,49,122],[62,50,123],[61,51,124],[61,52,125],[60,53,126],[60,54,126],[59,55,127],[59,56,128],[58,57,129],[58,58,129],[57,59,130],[57,60,131],[56,61,131],[56,62,132],[55,63,133],[55,64,133],[54,65,134],[53,66,134],[53,67,135],[52,68,135],[52,69,136],[51,70,137],[50,71,137],[50,72,137],[49,73,138],[49,74,138],[48,75,139],[48,76,139],[47,77,140],[47,78,140],[46,79,140],[46,80,141],[45,81,141],[45,82,141],[44,83,142],[44,84,142],[43,85,142],[43,86,142],[42,87,142],[42,88,142],[41,89,143],[41,90,143],[40,91,143],[40,92,143],[39,93,143],[39,94,143],[38,95,143],[38,96,142],[37,97,142],[37,98,142],[36,99,142],[36,100,142],[35,101,142],[35,102,141],[35,103,141],[34,104,141],[34,105,141],[33,106,140],[33,107,140],[33,108,140],[32,109,139],[32,110,139],[32,111,138],[31,112,138],[31,113,138],[31,114,137],[30,115,137],[30,116,136],[30,117,136],[29,118,135],[29,120,135],[29,121,134],[28,122,133],[28,123,133],[28,124,132],[28,125,132],[27,126,131],[27,127,130],[27,128,130],[27,129,129],[27,130,128],[26,132,128],[26,133,127],[26,134,126],[27,135,126],[27,136,125],[27,137,124],[27,138,123],[27,139,123],[27,141,122],[28,142,121],[28,143,120],[28,144,119],[29,145,118],[29,146,118],[30,147,117],[30,148,116],[31,150,115],[31,151,114],[32,152,113],[33,153,112],[33,154,111],[34,155,110],[35,157,109],[36,158,108],[37,159,107],[38,160,106],[39,161,105],[40,162,104],[41,163,103],[42,164,102],[43,165,101],[44,167,100],[45,168,99],[47,169,98],[48,170,97],[49,171,96],[51,172,95],[52,173,94],[53,174,93],[55,175,92],[56,176,91],[58,177,90],[59,178,89],[61,179,88],[62,180,87],[64,181,86],[66,182,85],[67,183,84],[69,184,83],[71,185,81],[72,186,80],[74,187,79],[76,188,78],[78,189,77],[80,190,76],[81,191,75],[83,192,74],[85,193,73],[87,194,71],[89,195,70],[91,196,69],[93,197,68],[95,198,67],[97,199,66],[99,200,64],[101,201,63],[103,201,62],[105,202,61],[107,203,60],[109,204,59],[111,205,57],[114,206,56],[116,207,55],[118,208,54],[120,208,52],[123,209,51],[125,210,50],[127,211,49],[130,212,47],[132,213,46],[134,213,45],[137,214,44],[139,215,42],[142,216,41],[144,216,40],[147,217,39],[149,218,37],[152,219,36],[154,219,35],[157,220,34],[160,221,32],[162,221,31],[165,222,30],[168,223,29],[170,223,28],[173,224,27],[176,225,26],[178,225,25],[181,226,24],[184,227,23],[187,227,22],[190,228,21],[192,228,20],[195,229,19],[198,230,18],[201,230,17],[204,231,16],[207,231,16],[210,232,15],[213,232,14],[216,233,13],[219,233,12],[221,234,11],[224,234,10],[227,235,10],[230,235,9],[233,236,8],[236,236,7],[239,237,7],[242,237,6],[245,238,5],[248,238,4],[251,239,3],[253,239,3]
    ];

    function colorViridis(t) {
        t = Math.max(0, Math.min(1, t));
        const n = VIRIDIS_DATA.length - 1;
        const i = Math.floor(t * n);
        const j = Math.ceil(t * n);
        
        if (i === j) {
            return VIRIDIS_DATA[i];
        }

        const f = t * n - i;
        return interpolateColor(VIRIDIS_DATA[i], VIRIDIS_DATA[j], f);
    }

    // HSL to RGB conversion helper
    function hslToRgb(h, s, l) {
        let r, g, b;

        if (s == 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // Initialize the application when the DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        if (document.readyState === 'loading') return;
        initialize();
    });
    if (document.readyState !== 'loading') {
        initialize();
    }
</script>

</body>
</html>